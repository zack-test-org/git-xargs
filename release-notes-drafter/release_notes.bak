import (
	"github.com/gruntwork-io/gruntwork-cli/errors"
	"gopkg.in/russross/blackfriday.v2"
)

const (
	ModulesAffectedHeading = "Modules affected"
	DescriptionHeading     = "Description"
	RelatedLinksHeading    = "Related links"
)

// List represents a markdown list, without the ListOpen and ListClose tokens
type List struct {
	IsOrdered bool
	Items     [][]markdown.Token
}

type Section struct {
	Preamble []markdown.Token
	Details  List
}

type ReleaseNote struct {
	ModulesAffected Section
	Description     Section
	RelatedLinks    Section
}

func RenderReleaseNote(releaseNote ReleaseNote) string {
	tokens := []markdown.Token{}
	tokens = append(tokens, RenderSection(ModulesAffectedHeading, releaseNote.ModulesAffected)...)
	tokens = append(tokens, RenderSection(DescriptionHeading, releaseNote.Description)...)
	tokens = append(tokens, RenderSection(RelatedLinksHeading, releaseNote.RelatedLinks)...)
	return markdown.New().RenderTokensToString(tokens)
}

func RenderSection(sectionHeading string, section Section) []markdown.Token {
	tokens := []markdown.Token{}
	tokens = append(
		tokens,
		&markdown.HeadingOpen{
			HLevel: 2,
			Lvl:    0,
		},
		&markdown.Text{
			Content: sectionHeading,
			Lvl:     1,
		},
		&markdown.HeadingClose{
			Lvl: 0,
		},
	)
	tokens = append(tokens, section.Preamble...)
	details := section.Details
	if details.IsOrdered {
		tokens = append(tokens, &markdown.OrderedListOpen{Lvl: 0})
	} else {
		tokens = append(tokens, &markdown.BulletListOpen{Lvl: 0})
	}
	for _, item := range details.Items {
		tokens = append(tokens, &markdown.ListItemOpen{Lvl: 1})
		tokens = append(tokens, item...)
		tokens = append(tokens, &markdown.ListItemClose{Lvl: 1})
	}
	if details.IsOrdered {
		tokens = append(tokens, &markdown.OrderedListClose{Lvl: 0})
	} else {
		tokens = append(tokens, &markdown.BulletListClose{Lvl: 0})
	}
	return tokens
}

func appendModulesAffected(releaseNote ReleaseNote, moduleNames []string) ReleaseNote {
	for _, moduleName := range moduleNames {
		item := []markdown.Token{
			&markdown.CodeInline{
				Content: moduleName,
				Lvl:     2,
			},
		}
		releaseNote.ModulesAffected.Details.Items = append(releaseNote.ModulesAffected.Details.Items, item)
	}
	return releaseNote
}

func appendDescription(releaseNote ReleaseNote, description string) ReleaseNote {
	item := []markdown.Token{
		&markdown.Text{
			Content: description,
			Lvl:     2,
		},
	}
	releaseNote.Description.Details.Items = append(releaseNote.Description.Details.Items, item)
	return releaseNote
}

func appendRelatedLinks(releaseNote ReleaseNote, link string) ReleaseNote {
	item := []markdown.Token{
		&markdown.LinkOpen{
			Href: link,
			Lvl:  2,
		},
		&markdown.LinkClose{
			Lvl: 2,
		},
	}
	releaseNote.RelatedLinks.Details.Items = append(releaseNote.RelatedLinks.Details.Items, item)
	return releaseNote
}

func parseReleaseNoteBody(releaseBody string) (ReleaseNote, error) {
	if releaseBody == "" {
		return ReleaseNote{}, nil
	}
	return parseFromMarkdown(releaseBody)
}

func parseFromMarkdown(body string) (ReleaseNote, error) {
	releaseNote := ReleaseNote{}
	md := markdown.New()
	tokens := md.Parse([]byte(body))
	for len(tokens) > 0 {
		_, isHeadingOpen := tokens[0].(*markdown.HeadingOpen)
		if isHeadingOpen {
			consumed, heading := parseHeading(tokens)
			if consumed == -1 || consumed >= len(tokens) {
				return releaseNote, errors.WithStackTrace(ReleaseNoteParsingError{body})
			}
			consumed, section := parseSection(tokens[consumed:])
			if consumed == -1 {
				return releaseNote, errors.WithStackTrace(ReleaseNoteParsingError{body})
			}
			switch heading {
			case ModulesAffectedHeading:
				releaseNote.ModulesAffected = section
			case DescriptionHeading:
				releaseNote.Description = section
			case RelatedLinksHeading:
				releaseNote.RelatedLinks = section
			default:
				return releaseNote, errors.WithStackTrace(ReleaseNoteParsingError{body})
			}
			tokens = tokens[consumed:]
		} else {
			tokens = tokens[1:]
		}
	}
	return releaseNote, nil
}

func parseSection(tokens []markdown.Token) (int, Section) {
	section := Section{}
	listOpenIdx := firstListOpenIdx(tokens)
	if listOpenIdx == -1 {
		return -1, section
	} else if listOpenIdx > 0 {
		section.Preamble = tokens[:listOpenIdx]
	}

	consumed, list := parseList(tokens[listOpenIdx:])
	section.Details = list
	return consumed, section
}

func parseHeading(tokens []markdown.Token) (int, string) {
	headingText := ""
	headingOpen, ok := tokens[0].(*markdown.HeadingOpen)
	if !ok {
		return -1, ""
	}
	consumed := len(tokens)
	for idx, token := range tokens[1:] {
		headingClose, ok := token.(*markdown.HeadingClose)
		if ok && headingClose.Lvl == headingOpen.Lvl {
			consumed = idx + 1
			break
		}
		headingText += parseText(token)
	}
	return consumed, headingText
}

func parseText(token markdown.Token) string {
	switch token := token.(type) {
	case *markdown.Text:
		return token.Content
	case *markdown.Inline:
		text := ""
		for _, token := range token.Children {
			text += parseText(token)
		}
		return text
	}
	return ""
}

func parseList(tokens []markdown.Token) (int, List) {
	list := List{}
	openToken := tokens[0]
	switch openToken.(type) {
	case *markdown.BulletListOpen:
	case *markdown.OrderedListOpen:
	default:
		return -1, list
	}

	closeIdx := listCloseIdx(openToken.Level(), tokens)
	if closeIdx == -1 {
		return -1, list
	}

	for idx := 0; idx < closeIdx; idx++ {
		switch token := tokens[idx].(type) {
		case *markdown.ListItemOpen:
			itemCloseIdx := listItemCloseIdx(token.Lvl, tokens[idx:])
			list.Items = append(list.Items, tokens[idx+1:itemCloseIdx])
		default:
			lastIdx := len(list.Items) - 1
			list.Items[lastIdx] = append(list.Items[lastIdx], tokens[idx])
		}
	}
	return closeIdx + 1, list
}

func firstListOpenIdx(tokens []markdown.Token) int {
	for idx, token := range tokens {
		switch token.(type) {
		case *markdown.BulletListOpen:
			return idx
		case *markdown.OrderedListOpen:
			return idx
		}
	}
	return -1
}

func listCloseIdx(level int, tokens []markdown.Token) int {
	for idx, token := range tokens {
		switch token := token.(type) {
		case *markdown.BulletListClose:
			if token.Lvl == level {
				return idx
			}
		case *markdown.OrderedListClose:
			if token.Lvl == level {
				return idx
			}
		}
	}
	return -1
}

func listItemCloseIdx(level int, tokens []markdown.Token) int {
	for idx, token := range tokens {
		_, ok := token.(*markdown.ListItemClose)
		if ok && token.Level() == level {
			return idx
		}
	}
	return -1
}
